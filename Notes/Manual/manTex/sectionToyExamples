The main purpose of this architecture is to analyze the cyclicity of time series data from one or more data sets. We start this tutorial by generating a toy data set using the \verb|create_toy| function, which will be explained in more detail later. For now, we can use the following commands to get started:

\begin{lstlisting}[label={lst:basic1},caption={Listing whatever},frame=single]
[toy_data,ss] = create_toy('periodic','rois',30,'shift',10);
cyclicity = analyze_cyclicity(toy_data);

% Generate plots
plot(toy_data.');
figure;
cyclicity_figs(cyclicity);

% Check permutation result
display([ss'; cyclicity.eperms{1}]);
\end{lstlisting}

Your plot of \verb|toy_data| should look something like \f~\ref{fig:basicsIn}. Note that the exact shifts of the trajectories is random, so your plot will not be identical. The figure generated by \verb|cyclicity_figs| should look like \f~\ref{fig:basicsOut} and the permutation result should match identically.
\begin{table}[H]
\begin{verbatim}
ans =

  Columns 1 through 12

     7    27    25     3    22    14     6    11    17     5    18    21
     7    27    25     3    22    14     6    11    17     5    18    21

  Columns 13 through 24

    24     2     1    16     4    19    23    10    12    28     8    20
    24     2     1    16     4    19    23    10    12    28     8    20

  Columns 25 through 30

    29    15    30     9    13    26
    29    15    30     9    13    26

\end{verbatim}
\end{table}

The \verb|analyze_cyclicity| function returns a structure array variable with fields \verb|phases|, \verb|eperms|, \verb|evals|, \verb|slm|, and \verb|subject|, each of which is a cell array. In the example above, only a single data set was analyzed so each cell contains only one element, but later we will see how to analyze multiple data sets in which case the cells will store one element for each data set analyzed. 

The contents of each variable can be seen in \f~\ref{fig:basicsOut}. The variable \verb|phases| stores the (complex valued) eigenvector associated with the largest eigenvalue of the lead matrix as discussed in \s~\ref{sec:sorting}. Note that the elements are not sorted. \verb|eperms| stores the sort order of \verb|phases| and this corresponds to the cyclic ordering of the processes. \verb|slm| stores the sorted lead matrix and \verb|subject| stores the subject number or id.

\begin{figure}
\centering
\includegraphics[width=.4\linewidth]{figs/basics1.eps}
\caption{Sample output of \texttt{toy\_data} variable from \l~\ref{lst:basic1}.}
\label{fig:basicsIn}
\end{figure}

\begin{figure}
\includegraphics[width=\linewidth]{figs/basicsOut.eps}
\caption{Results from \l~\ref{lst:basic1}.}
\label{fig:basicsOut}
\end{figure}

\subsection{Example 1}
\label{sec:twoSignals}
One problem that immediately arises is that so far we have no way of determining if there are multiple signals in the data set. Consider the set of trajectories created in \l~\ref{lst:ex1}. The first nine traces in the variable \verb|toy_data| will have one underlying function and the last nine, a different function. Note, however, that since both are \verb|'cyclic'| type functions, they are very similar. To see the recreate the results in the tutorial, load the file `ex1.mat' in the \textit{examples} folder (\verb|load('ex1.mat');|). 

\begin{lstlisting}[label={lst:ex1},caption={Data with two signals},frame=single]
% Generate trajectories
[toy_data1, ss1] = create_toy('cyclic');
[toy_data2, ss2] = create_toy('cyclic');
toy_data = [toy_data1; toy_data2];

% Analyze
cyclicity_figs(analyze_cyclicity(toy_data));
\end{lstlisting}

The results should look like \f~\ref{fig:ex1cycfig}. What this shows is a data set with two different (but similar) underlying functions. Looking at the plot of the eigenvalues we see two main eigenvalue pairs and some fuzzy behavior in the lead matrix. We would like to determine which regions are related to one another. One obvious way to do this is to calculate the Fourier expansion of each trace and group the regions by similarity. Since this data is very clean and constructed from a single (time reparameterized) sine wave, looking at the harmonic expansion works fairly well to distinguish groups of activity. In noisy data sets, this will likely be less clear, but may still provide some insight. It is one possible route of further exploration.

\begin{figure}
\includegraphics[width=\linewidth]{figs/ex1cycfig.eps}
\caption{Results of cyclicity analysis on \textit{Example 1} data.}
\label{fig:ex1cycfig}
\end{figure}

\subsection{Example 2}
Another consideration that so far has shown up in theory more than in practice is in the ordering of the regions. When the algorithm sorts the regions by phase angle, there is a potential for problems if the shifts encompass more than one period of the underlying function. The code in \l~\ref{lst:ex2} shows how to set up an example that will demonstrate this.

\begin{lstlisting}[label={lst:ex2},caption={Data with large shifts},frame=single]
% Generate data
[toy_data,ss] = create_toy('c','shift',300,'rois',30,'time',1000);
cyclicity = analyze_cyclicity(toy_data);

% Plot results
figure;
plot(toy_data');

figure;
subplot(121)
plot(cyclicity.phases{1}(ss))
subplot(122)
plot(cyclicity.phases{1}(cyclicity.eperms{1}))
\end{lstlisting}

\begin{figure}
\centering
\includegraphics[width=.7\textwidth]{figs/ex2.eps}
\caption{\small Results when \texttt{shift} is larger than a period of the underlying function. The plot on the left shows the phases ordered as they should be according to the amount that each trajectory is shifted. Note how the plot loops around multiple times. The plot on the right shows the phases ordered by the cyclicity algorithm. The algorithm cannot distinguish between the angles $\pi/4$ and $9\pi/4$ so it will not loop around as it should, but rather return a sort that passes over the entire period only once.}
\label{fig:ex2}
\end{figure}


\subsection{The \texttt{create\_toy} Function}
\input{listings/create_toyHelp}
The purpose of this function is to create a toy time series data set with desired attributes. The input and output are shown in the usage of the function. Most of the options are pretty clear as to what they do - \verb|time| changes the number of columns of the resulting matrix; \verb|rois| changes the number of rows; \verb|noise| adds gaussian noise so that the ratio of the standard deviation of the noise to the standard deviation of the signal is equal to \verb|noise|. The data types possible are \verb|'periodic'|, \verb|'cyclic'|, \verb|'gaussian'|, and \verb|'data'|. The \verb|'periodic'| and \verb|'gaussian'| types are simply sine waves and sums of gaussians with randomly generated mean values, respectively. The \verb|'cyclic'| type is a sine wave but with the time parameter distorted (reparameterized) to mimic the ideas discussed in \s~\ref{sec:sorting}. The \verb|'data'| type is a smoothed trace from an fMRI data set - it was chosen randomly, not because it showed any desirable properties. 
